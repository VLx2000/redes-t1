#!/usr/bin/env python3
import asyncio
from tcp import Servidor
from tcp import Conexao
import re


def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()


# funciona com mensagens quebradas mas n com varias msgs ao mesmo tempo
def dados_residuais(conexao, dados):
    tem_residuo = hasattr(conexao, 'residuo')   # verifica se conexao possui residuo
    if not tem_residuo:
        if dados.endswith(b'\n'):
        #if '\n' in dados:  # TO DO cortar dados no \n e criar dois residuos diferentes ???
            return dados        # se n tem residuo e termina com \n sisplesmente retorna o dado
        else:
            conexao.residuo = dados 
            return 0            # se n tem residuo e NÃO termina com \n cria novo residuo
    else:
        conexao.residuo += dados
        if dados.endswith(b'\n'):
            return conexao.residuo  # se termina com \n e tem residuo junta tudo e retorna o dado completo
        else:
            return 0                # se NÂO termina com \n adiciona nos residuos os dados e retorna um dado invalido

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    dados = dados_residuais(conexao, dados)
    #conexao.enviar(b':server PONG server :' + dados.split(b' ', 1)[1])
    if not dados == 0:
        if dados.startswith(b'PING '):
            retorna_PONG(conexao, dados) 
        print(conexao, dados)


def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)


def retorna_PONG(conexao, dados):
        codigo_ping = dados.split(b' ', 1)[1] # tentando pegar so o q vem depois de PING
        resposta_pong = b':server PONG server :' + codigo_ping   # formando o PONG
        conexao.enviar(resposta_pong)
            
            
servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()
