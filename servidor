#!/usr/bin/env python3
import asyncio
from tcp import Servidor
from tcp import Conexao
import re

apelidos_de_usuario = {}

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None


def sair(conexao):
    print(conexao, 'conexão fechada')
    conexao.fechar()
    

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)
    
    dados = dados_residuais(conexao, dados)        

    # Verificando se há algum \n dentre os dados
    if dados.find(b'\n') != -1:
        
        # Separando as mensagem pelo \n
        dados_separados = dados.split(b'\n')
        
        # Verificando se é uma mensagem de dados incompleta
        if not dados.endswith(b'\n'):
            conexao.residuo = dados_separados[len(dados_separados) - 1]     # atualizando resíduo  
            
            # residuo é retirado, deixando somente as mensagens que estão completas
            dados_separados.pop()                                           
    
        for i in range(0, len(dados_separados)):
            mensagem = dados_separados[i] + b'\n'   # adicionando \n que foi retirado do método .split() à mensagem
            if mensagem.startswith(b'PING'):
                retorna_PONG(conexao, mensagem)
            elif mensagem.startswith(b'NICK'):
                define_nick(conexao, mensagem)
            print(conexao, mensagem)
            

def conexao_aceita(conexao):
    print(conexao, 'nova conexão')
    conexao.registrar_recebedor(dados_recebidos)


def retorna_PONG(conexao, dados):
        codigo_ping = dados.split(b' ', 1)[1] # tentando pegar so o q vem depois de PING
        resposta_pong = b':server PONG server :' + codigo_ping   # formando o PONG
        conexao.enviar(resposta_pong)
        

def dados_residuais(conexao, dados):
    tem_residuo = hasattr(conexao, 'residuo')   # verifica se conexao possui residuo
    if not tem_residuo:
        if dados.endswith(b'\n'):
            return dados                        # se não tem residuo e termina com \n, retorna o dado
        else:
            conexao.residuo = dados             # se não tem residuo e NÃO termina com \n
            return conexao.residuo              # cria e retorna o novo resíduo
    else:
        conexao.residuo += dados
        return conexao.residuo                  # retorna o residuo completo, ou incompleto 


def define_nick(conexao, dados):
    ja_tem_apelido = hasattr(conexao, 'apelido')   # verifica se conexao ja possui apelido
    apelido_a_adicionar = dados.split(b' ', 1)[1].replace(b'\r\n', b'')
    if validar_nome(apelido_a_adicionar):                                  # se o apelido eh valido
        if apelido_a_adicionar.upper() in apelidos_de_usuario.values():    # e n esta no dicionario
            if ja_tem_apelido:
                resposta_nickname_in_use = b':server 433 %s %s :Nickname is already in use\r\n' % (conexao.apelido, apelido_a_adicionar)
            else:
                resposta_nickname_in_use = b':server 433 * %s :Nickname is already in use\r\n' % (apelido_a_adicionar)
            conexao.enviar(resposta_nickname_in_use)
        else:
            if ja_tem_apelido:
                resposta_troca = b':%s NICK %s\r\n' % (conexao.apelido, apelido_a_adicionar)
                conexao.enviar(resposta_troca)
            else:
                resposta_welcome = b':server 001 %s :Welcome\r\n' % (apelido_a_adicionar)
                resposta_file_missing = b':server 422 %s :MOTD File is missing\r\n' % (apelido_a_adicionar)
                conexao.enviar(resposta_welcome)
                conexao.enviar(resposta_file_missing)
            apelidos_de_usuario[conexao] = apelido_a_adicionar.upper()
            conexao.apelido = apelido_a_adicionar
    else:
        resposta_erroneus_nickname = b':server 432 * %s :Erroneous nickname\r\n' % (apelido_a_adicionar)
        conexao.enviar(resposta_erroneus_nickname)            
            
            
servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)
asyncio.get_event_loop().run_forever()